# SM100 资源占用分析

基于 `test_operator/mla_bwd/mla_bwd.cuh` 的代码分析以及 `SM100.md` 的硬件规格，以下是关于 SM100 架构上 MLA Backward 阶段 (head dim 128) 的 Shared Memory 和 TMEM 资源占用分析。

假设配置：`D_QK = 576`（`D_V=512`, `D_ROPE=64`），`B_H=128`，`B_TOPK=64`，2CTA 协作。

## 1. TMEM (Tensor Memory) 占用分析

SM100 的 TMEM 总容量为 256 KB，结构为 128 行 × 512 列 × 4 字节。该反向 kernel 通过 `tmem_cols` 对 TMEM 做静态列划分。

### 列分配情况
代码定义如下（`mla_bwd.cuh`）：
```cpp
struct tmem_cols {
    static constexpr int dQ = 0;
    static constexpr int dQ_RoPE = 256;
    static constexpr int dKV = 288;
    static constexpr int dKV_RoPE = 416;
    static constexpr int P = 448;
    static constexpr int dP = 480;
};
```

| 变量 | 描述 | 数据类型 | Shape | 起始列 | 结束列 | 占用列数 | 占用大小 (KB) | 备注 |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| `dQ` | dQ NoPE 累加器 | fp32 | [64, 512] | 0 | 256 | **256** | 128 | dQ 主体 |
| `dQ_RoPE` | dQ RoPE 累加器 | fp32 | [64, 64] | 256 | 288 | **32** | 16 | dQ rope |
| `dKV` | dKV NoPE 分块累加器 | fp32 | [64, 256] | 288 | 416 | **128** | 64 | part0/part1 时间复用 |
| `dKV_RoPE` | dKV RoPE 累加器 | fp32 | [64, 64] | 416 | 448 | **32** | 16 | dK rope |
| `P` | softmax(P) / logits 缓冲 | fp32 | [64, 64] | 448 | 480 | **32** | 16 | WG0/WG3 共享 |
| `dP` | dP 缓冲 | fp32 | [64, 64] | 480 | 512 | **32** | 16 | WG0/WG3 共享 |
| **总计** |  |  |  |  |  | **512** | **256** | |

### 结论
- **TMEM 使用量**: 256 KB (512 列)
- **TMEM 总容量**: 256 KB (512 列)
- **使用率**: **100%**

与前向类似，TMEM 已被完全占满，是该反向 kernel 的核心硬件约束之一。

---

## 2. Shared Memory (共享内存) 占用分析

SM100 每 SM 可配置的最大共享内存为 227 KB。该反向 kernel 使用 `SharedMemoryPlan` 管理共享内存。

### 内存布局计算
`SharedMemoryPlan` 包含一个联合体 `u`（运行阶段复用）和固定成员区。

#### A. Union 部分 (取最大值)

1. `u.q_kv`（Q+KV 计算阶段）
- `k_nope`: `[32, 512]` bf16 = `32*512*2` = **32,768 B**
- `k_rope`: `[32, 64]` bf16 = `32*64*2` = **4,096 B**
- `kv_peer`: `[32, 576]` bf16 = `32*576*2` = **36,864 B**
- `q_nope`: `[64, 512]` bf16 = `64*512*2` = **65,536 B**
- `q_rope`: `[64, 64]` bf16 = `64*64*2` = **8,192 B**
- 小计：**147,456 B**（144.0 KB）

2. `u.dq`（dQ 输出阶段）
- `dq`: `[64, 576]` bf16 = `64*576*2` = **73,728 B**（72.0 KB）

**Union 最大占用**: **147,456 B**（144.0 KB）

#### B. 固定成员部分

1. `dO`: `[64, 512]` bf16 = **65,536 B**（64.0 KB）
2. `s_ds`:
- `s`: `[64,64]` bf16 = **8,192 B**
- `ds`: `[64,64]` bf16 = **8,192 B**
- 合计 = **16,384 B**（16.0 KB）
3. `is_k_valid[B_TOPK/8]` = `64/8` = **8 B**
4. barriers: 共 19 个 `transac_bar_t`（按 8B/个估算）= **152 B**
5. `tmem_start_addr` = **4 B**
6. rowwise buffers:
- `rowwise_max_buf[128]` = 512 B
- `rowwise_li_buf[128]` = 512 B
- `rowwise_delta_buf[128]` = 512 B
- 合计 = **1,536 B**

**固定成员总计**: **83,620 B**（约 81.7 KB）

### 总占用量与使用率

| 组件 | 大小 (Bytes) | 大小 (KB) |
| :--- | :--- | :--- |
| Union (Max) | 147,456 | 144.0 |
| 固定成员 | 83,620 | 81.7 |
| **总计** | **231,076** | **225.7** |

- **SM100 共享内存上限**: 227 KB (232,448 Bytes)
- **预估使用量**: ~225.7 KB
- **使用率**: **~99.4%**

### 结论
反向 kernel 的共享内存使用率接近上限（~99.4%），明显高于前向。结合 TMEM 100% 占用，说明该实现是极限片上存储驱动设计：
- 依赖 `union` 做强复用（`q_kv` 与 `dq`）
- 依赖多组 transaction barrier 在 WG 间精细同步
- 几乎没有继续增大 tile / head 维度的余量

---

## 3. 总体结论

1. **TMEM 是硬上限**：512 列已全部分配，使用率 100%。
2. **SMEM 也接近硬上限**：约 225.7 KB / 227 KB，使用率约 99.4%。
3. **资源形态特征**：
- TMEM：用于 dQ/dKV/P/dP 的全流程累加与中间态。
- SMEM：用于 Q/KV/dO/s/ds、跨 WG 同步与 rowwise 辅助统计。
4. **优化含义**：后续若增加额外中间缓存（例如更深双缓冲、更多 mask staging）需要优先考虑“时间复用替代空间扩张”，否则容易直接触发 SMEM/TMEM 资源超限。

> 注：以上为基于 `mla_bwd.cuh` 的静态布局估算；`transac_bar_t` 的精确大小及最终 `sizeof(SharedMemoryPlan)` 仍以编译产物为准。
