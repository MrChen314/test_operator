# SM100 Head128 反向传播寄存器使用分析

基于 `test_operator/mla_bwd/mla_bwd.cu` 的代码分析。

## 1. SM100 寄存器架构概述

- **每SM寄存器总数**: 65,536个32位寄存器
- **每线程最大寄存器数**: 256个32位寄存器
- **Warpgroup寄存器限制**: 每个warpgroup最多256个寄存器/线程
- **寄存器溢出影响**: 当寄存器使用超过限制时，数据会被spill到local memory（实际是全局内存），导致严重的性能下降

## 2. 各Warpgroup寄存器分配情况

### 2.1 Warpgroup 0 (Softmax & dS Computation & dQ Output) - `warpgroup_idx == 0`

**功能**: 执行softmax计算、dS梯度计算、从TMEM读取dQ并写回全局内存

**寄存器使用分析**:

| 变量/数组 | 类型 | 大小 | 寄存器数 | 说明 |
|---------|------|------|---------|------|
| `row_lse` | float | 1 | 1 | 行级别的log-sum-exp值 |
| `global_row_idx` | int | 1 | 1 | 全局行索引 |
| `sm_scale, scale` | float | 2 | 2 | Softmax缩放因子 |
| `p` | float2[16] | 16 | 32 | P矩阵数据 (B_TOPK/2)/2 = 32/2 = 16 |
| `s_fp32` | float2[16] | 16 | 32 | Softmax结果（fp32格式） |
| `dp` | float2[16] | 16 | 32 | dP矩阵数据 |
| `ds_fp32` | __nv_bfloat162[16] | 16 | 16 | dS梯度（fp32格式） |
| `delta_val` | float | 1 | 1 | Delta值（sum(O * dO)） |
| `delta_float2` | float2 | 1 | 2 | Delta的float2格式 |
| `sm_scale_float2` | float2 | 1 | 2 | Softmax缩放因子的float2格式 |
| `neg_lse` | float2 | 1 | 2 | 负LSE值 |
| `tmem_base, tmem_lane, tmem_col, tmem_addr` | uint32_t | 4 | 4 | TMEM地址相关变量 |
| `dp_tmem_addr` | uint32_t | 1 | 1 | dP的TMEM地址 |
| `s_col_offset, ds_col_offset` | int | 2 | 2 | 列偏移量 |
| **dQ输出阶段** | | | | |
| `dq_chunk` | float2[8] | 8 | 16 | dQ NoPE分块读取缓冲 (NOPE_CHUNK_FLOAT2=8) |
| `dq_rope` | float2[16] | 16 | 32 | dQ RoPE数据 (ROPE_FLOAT2_PER_ROW=D_ROPE/4=16) |
| `row_in_cta, col_half, global_row` | int | 3 | 3 | dQ输出索引变量 |
| `tmem_base_dq, tmem_addr_dq0, tmem_addr_dq1, tmem_addr_dq_rope` | uint32_t | 4 | 4 | dQ TMEM地址 |
| 其他临时变量 | - | - | ~10 | 编译器生成的临时变量 |

**估算总寄存器数**: ~140个寄存器

**注意事项**:
- `p[16]` (32个寄存器) 和 `s_fp32[16]` (32个寄存器) 在softmax计算阶段有重叠
- `dp[16]` (32个寄存器) 和 `ds_fp32[16]` (16个寄存器) 在ds计算阶段与`s_fp32`重叠
- `dq_chunk[8]` (16个寄存器) 仅在dQ NoPE的8次chunk循环中使用，`dq_rope[16]` (32个寄存器) 在循环结束后使用，生命周期不重叠
- dQ输出采用分块策略（8 chunks × 16 floats），有效控制寄存器占用

**结论**: ✅ **安全** - 估算使用量约140个寄存器，远低于256的限制

---

### 2.2 Warpgroup 1 (KV Loading) - `warpgroup_idx == 1`

**功能**: 维护每块KV tile的TMA加载，以及通过cp_async从peer CTA传输kv_peer

**寄存器使用分析**:

| 变量/数组 | 类型 | 大小 | 寄存器数 | 说明 |
|---------|------|------|---------|------|
| `idx_in_warpgroup` | int | 1 | 1 | Warpgroup内索引 |
| `phase, kv_tile_idx` | int | 2 | 2 | 循环阶段与KV tile索引 |
| `gKV_tiles` | Tensor引用 | 1 | 1 | KV全局tensor分块引用 |
| `peer_kv_peer_ptr, peer_bar_ptr` | 指针 | 2 | 2 | cp_async的peer地址（仅warp 0使用） |
| 其他临时变量 | - | - | ~5 | 编译器生成的临时变量 |

**估算总寄存器数**: ~12个寄存器

**说明**: Q、dO的加载由prologue阶段warp 0通过TMA完成，WG1仅负责KV循环和kv_peer的cp_async传输，逻辑简单，寄存器占用极低。

**结论**: ✅ **安全** - 使用约12个寄存器，远低于256的限制

---

### 2.3 Warpgroup 2 (dKV Transfer) - `warpgroup_idx == 2`

**功能**: 从TMEM读取dKV并atomicAdd写入全局内存

**寄存器使用分析**:

| 变量/数组 | 类型 | 大小 | 寄存器数 | 说明 |
|---------|------|------|---------|------|
| `row, half` | int | 2 | 2 | 行索引和列半部分索引 |
| `tmem_base_wg2` | uint32_t | 1 | 1 | TMEM基地址 |
| `row_base, row_global` | int | 2 | 2 | 行偏移量 |
| `dkv_data` | float2[16] | 16 | 32 | dKV NoPE分块数据 (CHUNK_SIZE/2 = 32/2 = 16) |
| `dkv_rope_data` | float2[16] | 16 | 32 | dKV RoPE数据 (ROPE_COLS_PER_HALF/2 = 32/2 = 16) |
| `dst, src` | float* | 2 | 2 | 目标/源指针 |
| 其他临时变量 | - | - | ~5 | 编译器生成的临时变量 |

**估算总寄存器数**: ~76个寄存器

**注意事项**:
- 采用分块策略：`COLS_PER_HALF=128`，`CHUNK_SIZE=32`，每次仅加载`float2[16]`（32个寄存器）
- `dkv_data`在part0和part1的4次chunk循环中复用，`dkv_rope_data`在part2使用，生命周期不重叠
- 实际同时活跃的最大寄存器数约为32 + 32 + 其他 ≈ 76个

**结论**: ✅ **安全** - 分块优化后使用约76个寄存器，远低于256的限制

---

### 2.4 Warpgroup 3 (Matrix Multiplication) - `warpgroup_idx == 3`

**功能**: 执行矩阵乘法（P、dP、dKV、dQ计算）

**寄存器使用分析**:

| 变量/数组 | 类型 | 大小 | 寄存器数 | 说明 |
|---------|------|------|---------|------|
| `tP` | Tensor (fragment) | - | ~32 | P矩阵累加器 (2x1SM模式: warp 12参与，32线程，每线程64×64/32=128 float) |
| `tdP` | Tensor (fragment) | - | ~32 | dP矩阵累加器 (2x1SM模式) |
| `tdKV` | Tensor (fragment) | - | ~64 | dKV矩阵累加器 (WS模式: 128线程，每线程64×256/128=128 float) |
| `tdKV_RoPE` | Tensor (fragment) | - | ~16 | dKV RoPE累加器 (WS模式: 每线程64×64/128=32 float) |
| `tdQ_part0, tdQ_part1` | Tensor (fragment) | - | ~64×2 | dQ NoPE累加器 (WS模式: [64,256]×2) |
| `tdQ_RoPE` | Tensor (fragment) | - | ~16 | dQ RoPE累加器 (WS模式: [64,64]) |
| `tiled_mma_*` | TiledMMA对象 | 6 | ~6 | MMA对象引用 |
| `sQNoPE, sQRoPE, sKNoPE, sKRoPE, sdO` | Tensor | 5 | 5 | 共享内存tensor引用 |
| `sV, sS_mma, sDS_mma` | Tensor | 3 | 3 | V/S/dS矩阵引用 |
| `sdO_t_*, sQ_t_*, sDS_t_*` | Tensor | 6 | 6 | 转置tensor引用 |
| `sK_*_t_*, sK_peer_*_t_*` | Tensor | 4 | 4 | K转置tensor引用 |
| 其他临时变量 | - | - | ~20 | 编译器生成的临时变量 |

**估算总寄存器数**: ~180个寄存器（MMA由warp 12的32个线程执行）

**注意事项**:
- **tP/tdP (2x1SM模式)**: 使用`SM100_MMA_F16BF16_2x1SM_SS_NOELECT`，仅warp 12（warp_idx==12）的32个线程参与
- **tdKV/tdKV_RoPE/tdQ (WS模式)**: 使用`SM100_MMA_F16BF16_WS_SS_NOELECT`，整个warpgroup 128线程参与
- `tP`和`tdP`的生命周期不重叠，`tdKV`和`tdKV_RoPE`分阶段使用
- 实际同时活跃的最大寄存器数取决于MMA指令的累加器布局

**结论**: ⚠️ **需要注意** - MMA warp估算使用约180个寄存器，留有约76个寄存器缓冲。需监控编译后实际使用量。

---

## 3. 寄存器溢出风险评估

### 3.1 各Warpgroup风险等级

| Warpgroup | 估算使用量 | 剩余空间 | 风险等级 |
|-----------|-----------|---------|---------|
| Warpgroup 0 | ~140 | ~116 | 🟢 **低风险** |
| Warpgroup 1 | ~12 | ~244 | 🟢 **低风险** |
| Warpgroup 2 | ~76 | ~180 | 🟢 **低风险** |
| Warpgroup 3 | ~180 | ~76 | 🟡 **中等风险** |

### 3.2 代码优化点（相比旧版）

1. **WG0 dQ输出分块**: 使用8次chunk循环（`dq_chunk[8]`）替代一次性加载，将dQ NoPE的寄存器占用从256×2/2=256个float降至16个float（8个float2）
2. **WG2 dKV分块**: 使用`CHUNK_SIZE=32`的分块处理，`dkv_data`从float2[64]降至float2[16]，寄存器占用从128降至32
3. **无显式warpgroup_reg_alloc/dealloc**: 当前代码未使用`cutlass::arch::warpgroup_reg_alloc/dealloc`，由编译器自动分配

### 3.3 寄存器溢出检测方法

要确认是否存在寄存器溢出，可以：

1. **编译时检查**:
   ```bash
   nvcc --ptxas-options=-v your_kernel.cu
   ```
   查看输出中的 `reg` 字段，确认每个kernel的实际寄存器使用量

2. **运行时检查**:
   ```bash
   nvprof --print-gpu-trace your_program
   ```
   查看是否有大量的local memory访问（spill的迹象）

3. **使用Nsight Compute**:
   ```bash
   ncu --set full your_program
   ```
   查看详细的寄存器使用和spill统计

## 4. 优化建议

### 4.1 如果发现寄存器溢出

1. **Warpgroup 3 (MMA Warp)**:
   - 检查是否可以减少累加器的大小
   - 考虑使用更小的tile size
   - 评估是否可引入`warpgroup_reg_alloc`显式控制

2. **寄存器重用**:
   - 确保变量生命周期不重叠
   - 使用`__restrict__`关键字帮助编译器优化

### 4.2 当前代码的优化点

1. ✅ **良好的分块策略**: WG0的dQ输出、WG2的dKV传输均采用分块，有效控制寄存器占用
2. ✅ **WG2已优化**: 从原估算172个寄存器降至约76个
3. ✅ **生命周期管理**: 变量作用域清晰，避免不必要的寄存器占用

## 5. 结论

**总体评估**: ✅ **寄存器使用在安全范围内**

- Warpgroup 0、1、2的寄存器使用均在安全范围内
- Warpgroup 3（MMA warp）估算约180个寄存器，留有约76个缓冲
- 当前代码通过分块优化，已显著降低WG0和WG2的寄存器压力

**建议**:
- 使用`--ptxas-options=-v`确认各warpgroup的实际寄存器使用量
- 监控性能指标，如出现性能下降可检查是否有寄存器spill
- 若未来增加功能，需重新评估所有warpgroup的寄存器使用情况
